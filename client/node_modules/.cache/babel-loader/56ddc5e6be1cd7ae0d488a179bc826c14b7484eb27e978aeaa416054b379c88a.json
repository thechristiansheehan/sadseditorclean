{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1;\nvar GB18030_CODE = -2;\nvar SEQ_START = -10;\nvar NODE_START = -1000;\nvar UNASSIGNED_NODE = new Array(0x100);\nvar DEF_CHAR = -1;\nfor (var i = 0; i < 0x100; i++) {\n  UNASSIGNED_NODE[i] = UNASSIGNED;\n}\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) {\n    throw new Error(\"DBCS codec is called without the data.\");\n  }\n  if (!codecOptions.table) {\n    throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n  }\n\n  // Load tables.\n  var mappingTable = codecOptions.table();\n\n  // Decode tables: MBCS -> Unicode.\n\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.\n  this.decodeTableSeq = [];\n\n  // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n  for (var i = 0; i < mappingTable.length; i++) {\n    this._addDecodeChunk(mappingTable[i]);\n  }\n\n  // Load & create GB18030 tables when needed.\n  if (typeof codecOptions.gb18030 === \"function\") {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n    // Add GB18030 common decode nodes.\n    var commonThirdByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n    var commonFourthByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n    // Fill out the tree\n    var firstByteNode = this.decodeTables[0];\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\");\n        }\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue;\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\");\n          }\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) {\n              fourthByteNode[l] = GB18030_CODE;\n            }\n          }\n        }\n      }\n    }\n  }\n  this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n  // Encode tables: Unicode -> DBCS.\n\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n  this.encodeTable = [];\n\n  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n  this.encodeTableSeq = [];\n\n  // Some chars can be decoded, but need not be encoded.\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) {\n    for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n      var val = codecOptions.encodeSkipVals[i];\n      if (typeof val === \"number\") {\n        skipEncodeChars[val] = true;\n      } else {\n        for (var j = val.from; j <= val.to; j++) {\n          skipEncodeChars[j] = true;\n        }\n      }\n    }\n  }\n\n  // Use decode trie to recursively fill out encode tables.\n  this._fillEncodeTable(0, 0, skipEncodeChars);\n\n  // Add more encoding pairs when needed.\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) {\n      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) {\n        this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n      }\n    }\n  }\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0][\"?\"];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n  for (; addr > 0; addr >>>= 8) {\n    bytes.push(addr & 0xFF);\n  }\n  if (bytes.length == 0) {\n    bytes.push(0);\n  }\n  var node = this.decodeTables[0];\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else {\n      throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n  }\n  return node;\n};\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16);\n\n  // Choose the decoding node where we'll write our chars.\n  var writeTable = this._getDecodeTrieNode(curAddr);\n  curAddr = curAddr & 0xFF;\n\n  // Write all other elements of the chunk to the table.\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n        if (code >= 0xD800 && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (codeTrail >= 0xDC00 && codeTrail < 0xE000) {\n            writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n          } else {\n            throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n          }\n        } else if (code > 0x0FF0 && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n          for (var m = 0; m < len; m++) {\n            seq.push(part.charCodeAt(l++));\n          } // Simple variation: don't support surrogates or subsequences in seq.\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else {\n          writeTable[curAddr++] = code;\n        } // Basic char\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n      for (var l = 0; l < part; l++) {\n        writeTable[curAddr++] = charCode++;\n      }\n    } else {\n      throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n  }\n  if (curAddr > 0xFF) {\n    throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n  }\n};\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n  if (this.encodeTable[high] === undefined) {\n    this.encodeTable[high] = UNASSIGNED_NODE.slice(0);\n  } // Create bucket on demand.\n  return this.encodeTable[high];\n};\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) {\n    this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;\n  } // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) {\n    bucket[low] = dbcsCode;\n  }\n};\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  var node;\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  }\n\n  // Traverse the character tree, allocating new nodes as needed.\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === \"object\") {\n      node = oldVal;\n    } else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) {\n        node[DEF_CHAR] = oldVal;\n      }\n    }\n  }\n\n  // Set the leaf to given dbcsCode.\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  var hasValues = false;\n  var subNodeEmpty = {};\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) {\n      continue;\n    }\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode);\n      hasValues = true;\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode;\n      if (!subNodeEmpty[subNodeIdx]) {\n        // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) {\n          hasValues = true;\n        } else {\n          subNodeEmpty[subNodeIdx] = true;\n        }\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n      hasValues = true;\n    }\n  }\n  return hasValues;\n};\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined;\n\n  // Static data\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3));\n  var leadSurrogate = this.leadSurrogate;\n  var seqObj = this.seqObj;\n  var nextChar = -1;\n  var i = 0;\n  var j = 0;\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    }\n\n    // 1. Handle surrogates.\n    if (uCode >= 0xD800 && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode;\n          // Double lead surrogate found.\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n      leadSurrogate = -1;\n    }\n\n    // 2. Convert uCode character.\n    var dbcsCode = UNASSIGNED;\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n      if (typeof resCode === \"object\") {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode === \"number\") {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {\n          // TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) {\n        dbcsCode = subtable[uCode & 0xFF];\n      }\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    }\n\n    // 3. Write dbcsCode character.\n    if (dbcsCode === UNASSIGNED) {\n      dbcsCode = this.defaultCharSingleByte;\n    }\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    } else {\n      newBuf[j++] = dbcsCode >>> 24;\n      newBuf[j++] = dbcsCode >>> 16 & 0xFF;\n      newBuf[j++] = dbcsCode >>> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) {\n    return;\n  } // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10);\n  var j = 0;\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {\n      // See todo above.\n    }\n    this.seqObj = undefined;\n  }\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n  return newBuf.slice(0, j);\n};\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBytes = [];\n\n  // Static data\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2);\n  var nodeIdx = this.nodeIdx;\n  var prevBytes = this.prevBytes;\n  var prevOffset = this.prevBytes.length;\n  var seqStart = -this.prevBytes.length; // idx of the start of current parsed sequence.\n  var uCode;\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];\n\n    // Lookup in current trie node.\n    var uCode = this.decodeTables[nodeIdx][curByte];\n    if (uCode >= 0) {\n      // Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n      i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);\n      }\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n      uCode = seq[seq.length - 1];\n    } else {\n      throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n    }\n\n    // Write the character to buffer, handling higher planes using surrogate pair.\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 | uCode >> 10;\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 | uCode & 0x3FF;\n    }\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8;\n\n    // Reset trie node.\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n  this.nodeIdx = nodeIdx;\n  this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n  return newBuf.slice(0, j).toString(\"ucs2\");\n};\nDBCSDecoder.prototype.end = function () {\n  var ret = \"\";\n\n  // Try to parse all remaining chars.\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var bytesArr = this.prevBytes.slice(1);\n\n    // Parse remaining as usual.\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    if (bytesArr.length > 0) {\n      ret += this.write(bytesArr);\n    }\n  }\n  this.prevBytes = [];\n  this.nodeIdx = 0;\n  return ret;\n};\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n  if (table[0] > val) {\n    return -1;\n  }\n  var l = 0;\n  var r = table.length;\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + (r - l + 1 >> 1);\n    if (table[mid] <= val) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  return l;\n}","map":{"version":3,"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","gb18030","commonThirdByteNodeIdx","push","commonFourthByteNodeIdx","firstByteNode","secondByteNode","j","thirdByteNode","k","fourthByteNode","l","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","node","toString","chunk","curAddr","parseInt","writeTable","part","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","hasValues","subNodeEmpty","mbCode","subNodeIdx","newPrefix","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBytes","buf","prevOffset","seqStart","curByte","ptr","uCodeLead","concat","ret","bytesArr","r","mid"],"sources":["C:/Users/Flame/sadseditor/sadseditor/client/node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-codec.js"],"sourcesContent":["\"use strict\"\nvar Buffer = require(\"safer-buffer\").Buffer\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec\n\nvar UNASSIGNED = -1\nvar GB18030_CODE = -2\nvar SEQ_START = -10\nvar NODE_START = -1000\nvar UNASSIGNED_NODE = new Array(0x100)\nvar DEF_CHAR = -1\n\nfor (var i = 0; i < 0x100; i++) { UNASSIGNED_NODE[i] = UNASSIGNED }\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec (codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName\n  if (!codecOptions) { throw new Error(\"DBCS codec is called without the data.\") }\n  if (!codecOptions.table) { throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\") }\n\n  // Load tables.\n  var mappingTable = codecOptions.table()\n\n  // Decode tables: MBCS -> Unicode.\n\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n  this.decodeTables = []\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0) // Create root node.\n\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.\n  this.decodeTableSeq = []\n\n  // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n  for (var i = 0; i < mappingTable.length; i++) { this._addDecodeChunk(mappingTable[i]) }\n\n  // Load & create GB18030 tables when needed.\n  if (typeof codecOptions.gb18030 === \"function\") {\n    this.gb18030 = codecOptions.gb18030() // Load GB18030 ranges.\n\n    // Add GB18030 common decode nodes.\n    var commonThirdByteNodeIdx = this.decodeTables.length\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0))\n\n    var commonFourthByteNodeIdx = this.decodeTables.length\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0))\n\n    // Fill out the tree\n    var firstByteNode = this.decodeTables[0]\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]]\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\")\n        }\n\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]]\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\")\n          }\n\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]]\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) { fourthByteNode[l] = GB18030_CODE }\n          }\n        }\n      }\n    }\n  }\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode\n\n  // Encode tables: Unicode -> DBCS.\n\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n  this.encodeTable = []\n\n  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n  this.encodeTableSeq = []\n\n  // Some chars can be decoded, but need not be encoded.\n  var skipEncodeChars = {}\n  if (codecOptions.encodeSkipVals) {\n    for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n      var val = codecOptions.encodeSkipVals[i]\n      if (typeof val === \"number\") { skipEncodeChars[val] = true } else {\n        for (var j = val.from; j <= val.to; j++) { skipEncodeChars[j] = true }\n      }\n    }\n  }\n\n  // Use decode trie to recursively fill out encode tables.\n  this._fillEncodeTable(0, 0, skipEncodeChars)\n\n  // Add more encoding pairs when needed.\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) {\n      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) { this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]) }\n    }\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)]\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0][\"?\"]\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0)\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder\nDBCSCodec.prototype.decoder = DBCSDecoder\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = []\n  for (; addr > 0; addr >>>= 8) { bytes.push(addr & 0xFF) }\n  if (bytes.length == 0) { bytes.push(0) }\n\n  var node = this.decodeTables[0]\n  for (var i = bytes.length - 1; i > 0; i--) { // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]]\n\n    if (val == UNASSIGNED) { // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0))\n    } else if (val <= NODE_START) { // Existing node.\n      node = this.decodeTables[NODE_START - val]\n    } else { throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16)) }\n  }\n  return node\n}\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16)\n\n  // Choose the decoding node where we'll write our chars.\n  var writeTable = this._getDecodeTrieNode(curAddr)\n  curAddr = curAddr & 0xFF\n\n  // Write all other elements of the chunk to the table.\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k]\n    if (typeof part === \"string\") { // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++)\n        if (code >= 0xD800 && code < 0xDC00) { // Decode surrogate\n          var codeTrail = part.charCodeAt(l++)\n          if (codeTrail >= 0xDC00 && codeTrail < 0xE000) { writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00) } else { throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]) }\n        } else if (code > 0x0FF0 && code <= 0x0FFF) { // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2\n          var seq = []\n          for (var m = 0; m < len; m++) { seq.push(part.charCodeAt(l++)) } // Simple variation: don't support surrogates or subsequences in seq.\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length\n          this.decodeTableSeq.push(seq)\n        } else { writeTable[curAddr++] = code } // Basic char\n      }\n    } else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1\n      for (var l = 0; l < part; l++) { writeTable[curAddr++] = charCode++ }\n    } else { throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]) }\n  }\n  if (curAddr > 0xFF) { throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr) }\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8 // This could be > 0xFF because of astral characters.\n  if (this.encodeTable[high] === undefined) {\n    this.encodeTable[high] = UNASSIGNED_NODE.slice(0)\n  } // Create bucket on demand.\n  return this.encodeTable[high]\n}\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode)\n  var low = uCode & 0xFF\n  if (bucket[low] <= SEQ_START) { this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode } // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) { bucket[low] = dbcsCode }\n}\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0]\n  var bucket = this._getEncodeBucket(uCode)\n  var low = uCode & 0xFF\n\n  var node\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]]\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {}\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low] // If a char was set before - make it a single-char subsequence.\n    bucket[low] = SEQ_START - this.encodeTableSeq.length\n    this.encodeTableSeq.push(node)\n  }\n\n  // Traverse the character tree, allocating new nodes as needed.\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode]\n    if (typeof oldVal === \"object\") { node = oldVal } else {\n      node = node[uCode] = {}\n      if (oldVal !== undefined) { node[DEF_CHAR] = oldVal }\n    }\n  }\n\n  // Set the leaf to given dbcsCode.\n  uCode = seq[seq.length - 1]\n  node[uCode] = dbcsCode\n}\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx]\n  var hasValues = false\n  var subNodeEmpty = {}\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i]\n    var mbCode = prefix + i\n    if (skipEncodeChars[mbCode]) { continue }\n\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode)\n      hasValues = true\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode\n      if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = (mbCode << 8) >>> 0  // NOTE: '>>> 0' keeps 32-bit num positive.\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) { hasValues = true } else { subNodeEmpty[subNodeIdx] = true }\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode)\n      hasValues = true\n    }\n  }\n  return hasValues\n}\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder (options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1\n  this.seqObj = undefined\n\n  // Static data\n  this.encodeTable = codec.encodeTable\n  this.encodeTableSeq = codec.encodeTableSeq\n  this.defaultCharSingleByte = codec.defCharSB\n  this.gb18030 = codec.gb18030\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3))\n  var leadSurrogate = this.leadSurrogate\n  var seqObj = this.seqObj\n  var nextChar = -1\n  var i = 0; var j = 0\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break\n      var uCode = str.charCodeAt(i++)\n    } else {\n      var uCode = nextChar\n      nextChar = -1\n    }\n\n    // 1. Handle surrogates.\n    if (uCode >= 0xD800 && uCode < 0xE000) { // Char is one of surrogates.\n      if (uCode < 0xDC00) { // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode\n          continue\n        } else {\n          leadSurrogate = uCode\n          // Double lead surrogate found.\n          uCode = UNASSIGNED\n        }\n      } else { // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00)\n          leadSurrogate = -1\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode; uCode = UNASSIGNED // Write an error, then current char.\n      leadSurrogate = -1\n    }\n\n    // 2. Convert uCode character.\n    var dbcsCode = UNASSIGNED\n    if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n      var resCode = seqObj[uCode]\n      if (typeof resCode === \"object\") { // Sequence continues.\n        seqObj = resCode\n        continue\n      } else if (typeof resCode === \"number\") { // Sequence finished. Write it.\n        dbcsCode = resCode\n      } else if (resCode == undefined) { // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR]\n        if (resCode !== undefined) {\n          dbcsCode = resCode // Found. Write it.\n          nextChar = uCode // Current character will be written too in the next iteration.\n        } else {\n          // TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n      seqObj = undefined\n    } else if (uCode >= 0) {  // Regular character\n      var subtable = this.encodeTable[uCode >> 8]\n      if (subtable !== undefined) { dbcsCode = subtable[uCode & 0xFF] }\n\n      if (dbcsCode <= SEQ_START) { // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode]\n        continue\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode)\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx])\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10\n          newBuf[j++] = 0x30 + dbcsCode\n          continue\n        }\n      }\n    }\n\n    // 3. Write dbcsCode character.\n    if (dbcsCode === UNASSIGNED) { dbcsCode = this.defaultCharSingleByte }\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8   // high byte\n      newBuf[j++] = dbcsCode & 0xFF // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16\n      newBuf[j++] = (dbcsCode >> 8) & 0xFF\n      newBuf[j++] = dbcsCode & 0xFF\n    } else {\n      newBuf[j++] = dbcsCode >>> 24\n      newBuf[j++] = (dbcsCode >>> 16) & 0xFF\n      newBuf[j++] = (dbcsCode >>> 8) & 0xFF\n      newBuf[j++] = dbcsCode & 0xFF\n    }\n  }\n\n  this.seqObj = seqObj\n  this.leadSurrogate = leadSurrogate\n  return newBuf.slice(0, j)\n}\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) { return } // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10); var j = 0\n\n  if (this.seqObj) { // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR]\n    if (dbcsCode !== undefined) { // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode\n      } else {\n        newBuf[j++] = dbcsCode >> 8   // high byte\n        newBuf[j++] = dbcsCode & 0xFF // low byte\n      }\n    } else {\n      // See todo above.\n    }\n    this.seqObj = undefined\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte\n    this.leadSurrogate = -1\n  }\n\n  return newBuf.slice(0, j)\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder (options, codec) {\n  // Decoder state\n  this.nodeIdx = 0\n  this.prevBytes = []\n\n  // Static data\n  this.decodeTables = codec.decodeTables\n  this.decodeTableSeq = codec.decodeTableSeq\n  this.defaultCharUnicode = codec.defaultCharUnicode\n  this.gb18030 = codec.gb18030\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2)\n  var nodeIdx = this.nodeIdx\n  var prevBytes = this.prevBytes; var prevOffset = this.prevBytes.length\n  var seqStart = -this.prevBytes.length // idx of the start of current parsed sequence.\n  var uCode\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset]\n\n    // Lookup in current trie node.\n    var uCode = this.decodeTables[nodeIdx][curByte]\n\n    if (uCode >= 0) {\n      // Normal character, just use it.\n    } else if (uCode === UNASSIGNED) { // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0)\n      i = seqStart // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30)\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 +\n                          (((i - 2 >= 0) ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 +\n                          (((i - 1 >= 0) ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 +\n                          (curByte - 0x30)\n      }\n      var idx = findIdx(this.gb18030.gbChars, ptr)\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx]\n    } else if (uCode <= NODE_START) { // Go to next trie node.\n      nodeIdx = NODE_START - uCode\n      continue\n    } else if (uCode <= SEQ_START) { // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode]\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k]\n        newBuf[j++] = uCode & 0xFF\n        newBuf[j++] = uCode >> 8\n      }\n      uCode = seq[seq.length - 1]\n    } else { throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte) }\n\n    // Write the character to buffer, handling higher planes using surrogate pair.\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000\n      var uCodeLead = 0xD800 | (uCode >> 10)\n      newBuf[j++] = uCodeLead & 0xFF\n      newBuf[j++] = uCodeLead >> 8\n\n      uCode = 0xDC00 | (uCode & 0x3FF)\n    }\n    newBuf[j++] = uCode & 0xFF\n    newBuf[j++] = uCode >> 8\n\n    // Reset trie node.\n    nodeIdx = 0; seqStart = i + 1\n  }\n\n  this.nodeIdx = nodeIdx\n  this.prevBytes = (seqStart >= 0)\n    ? Array.prototype.slice.call(buf, seqStart)\n    : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf))\n\n  return newBuf.slice(0, j).toString(\"ucs2\")\n}\n\nDBCSDecoder.prototype.end = function () {\n  var ret = \"\"\n\n  // Try to parse all remaining chars.\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode\n    var bytesArr = this.prevBytes.slice(1)\n\n    // Parse remaining as usual.\n    this.prevBytes = []\n    this.nodeIdx = 0\n    if (bytesArr.length > 0) { ret += this.write(bytesArr) }\n  }\n\n  this.prevBytes = []\n  this.nodeIdx = 0\n  return ret\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx (table, val) {\n  if (table[0] > val) { return -1 }\n\n  var l = 0; var r = table.length\n  while (l < r - 1) { // always table[l] <= val < table[r]\n    var mid = l + ((r - l + 1) >> 1)\n    if (table[mid] <= val) { l = mid } else { r = mid }\n  }\n  return l\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}