{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Export Node.js internal encodings.\n\nmodule.exports = {\n  // Encodings\n  utf8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  cesu8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  unicode11utf8: \"utf8\",\n  ucs2: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  utf16le: \"ucs2\",\n  binary: {\n    type: \"_internal\"\n  },\n  base64: {\n    type: \"_internal\"\n  },\n  hex: {\n    type: \"_internal\"\n  },\n  // Codec.\n  _internal: InternalCodec\n};\n\n// ------------------------------------------------------------------------------\n\nfunction InternalCodec(codecOptions, iconv) {\n  this.enc = codecOptions.encodingName;\n  this.bomAware = codecOptions.bomAware;\n  if (this.enc === \"base64\") {\n    this.encoder = InternalEncoderBase64;\n  } else if (this.enc === \"utf8\") {\n    this.encoder = InternalEncoderUtf8;\n  } else if (this.enc === \"cesu8\") {\n    this.enc = \"utf8\"; // Use utf8 for decoding.\n    this.encoder = InternalEncoderCesu8;\n\n    // Add decoder for versions of Node not supporting CESU-8\n    if (Buffer.from(\"eda0bdedb2a9\", \"hex\").toString() !== \"ðŸ’©\") {\n      this.decoder = InternalDecoderCesu8;\n      this.defaultCharUnicode = iconv.defaultCharUnicode;\n    }\n  }\n}\nInternalCodec.prototype.encoder = InternalEncoder;\nInternalCodec.prototype.decoder = InternalDecoder;\n\n// ------------------------------------------------------------------------------\n\n// We use node.js internal decoder. Its signature is the same as ours.\nvar StringDecoder = require(\"string_decoder\").StringDecoder;\nfunction InternalDecoder(options, codec) {\n  this.decoder = new StringDecoder(codec.enc);\n}\nInternalDecoder.prototype.write = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf);\n  }\n  return this.decoder.write(buf);\n};\nInternalDecoder.prototype.end = function () {\n  return this.decoder.end();\n};\n\n// ------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder(options, codec) {\n  this.enc = codec.enc;\n}\nInternalEncoder.prototype.write = function (str) {\n  return Buffer.from(str, this.enc);\n};\nInternalEncoder.prototype.end = function () {};\n\n// ------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\nfunction InternalEncoderBase64(options, codec) {\n  this.prevStr = \"\";\n}\nInternalEncoderBase64.prototype.write = function (str) {\n  str = this.prevStr + str;\n  var completeQuads = str.length - str.length % 4;\n  this.prevStr = str.slice(completeQuads);\n  str = str.slice(0, completeQuads);\n  return Buffer.from(str, \"base64\");\n};\nInternalEncoderBase64.prototype.end = function () {\n  return Buffer.from(this.prevStr, \"base64\");\n};\n\n// ------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\nfunction InternalEncoderCesu8(options, codec) {}\nInternalEncoderCesu8.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length * 3);\n  var bufIdx = 0;\n  for (var i = 0; i < str.length; i++) {\n    var charCode = str.charCodeAt(i);\n    // Naive implementation, but it works because CESU-8 is especially easy\n    // to convert from UTF-16 (which all JS strings are encoded in).\n    if (charCode < 0x80) {\n      buf[bufIdx++] = charCode;\n    } else if (charCode < 0x800) {\n      buf[bufIdx++] = 0xC0 + (charCode >>> 6);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    } else {\n      // charCode will always be < 0x10000 in javascript.\n      buf[bufIdx++] = 0xE0 + (charCode >>> 12);\n      buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    }\n  }\n  return buf.slice(0, bufIdx);\n};\nInternalEncoderCesu8.prototype.end = function () {};\n\n// ------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\nfunction InternalDecoderCesu8(options, codec) {\n  this.acc = 0;\n  this.contBytes = 0;\n  this.accBytes = 0;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n}\nInternalDecoderCesu8.prototype.write = function (buf) {\n  var acc = this.acc;\n  var contBytes = this.contBytes;\n  var accBytes = this.accBytes;\n  var res = \"\";\n  for (var i = 0; i < buf.length; i++) {\n    var curByte = buf[i];\n    if ((curByte & 0xC0) !== 0x80) {\n      // Leading byte\n      if (contBytes > 0) {\n        // Previous code is invalid\n        res += this.defaultCharUnicode;\n        contBytes = 0;\n      }\n      if (curByte < 0x80) {\n        // Single-byte code\n        res += String.fromCharCode(curByte);\n      } else if (curByte < 0xE0) {\n        // Two-byte code\n        acc = curByte & 0x1F;\n        contBytes = 1;\n        accBytes = 1;\n      } else if (curByte < 0xF0) {\n        // Three-byte code\n        acc = curByte & 0x0F;\n        contBytes = 2;\n        accBytes = 1;\n      } else {\n        // Four or more are not supported for CESU-8.\n        res += this.defaultCharUnicode;\n      }\n    } else {\n      // Continuation byte\n      if (contBytes > 0) {\n        // We're waiting for it.\n        acc = acc << 6 | curByte & 0x3f;\n        contBytes--;\n        accBytes++;\n        if (contBytes === 0) {\n          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n          if (accBytes === 2 && acc < 0x80 && acc > 0) {\n            res += this.defaultCharUnicode;\n          } else if (accBytes === 3 && acc < 0x800) {\n            res += this.defaultCharUnicode;\n          } else {\n            // Actually add character.\n            res += String.fromCharCode(acc);\n          }\n        }\n      } else {\n        // Unexpected continuation byte\n        res += this.defaultCharUnicode;\n      }\n    }\n  }\n  this.acc = acc;\n  this.contBytes = contBytes;\n  this.accBytes = accBytes;\n  return res;\n};\nInternalDecoderCesu8.prototype.end = function () {\n  var res = 0;\n  if (this.contBytes > 0) {\n    res += this.defaultCharUnicode;\n  }\n  return res;\n};\n\n// ------------------------------------------------------------------------------\n// check the chunk boundaries for surrogate pair\n\nfunction InternalEncoderUtf8(options, codec) {\n  this.highSurrogate = \"\";\n}\nInternalEncoderUtf8.prototype.write = function (str) {\n  if (this.highSurrogate) {\n    str = this.highSurrogate + str;\n    this.highSurrogate = \"\";\n  }\n  if (str.length > 0) {\n    var charCode = str.charCodeAt(str.length - 1);\n    if (charCode >= 0xd800 && charCode < 0xdc00) {\n      this.highSurrogate = str[str.length - 1];\n      str = str.slice(0, str.length - 1);\n    }\n  }\n  return Buffer.from(str, this.enc);\n};\nInternalEncoderUtf8.prototype.end = function () {\n  if (this.highSurrogate) {\n    var str = this.highSurrogate;\n    this.highSurrogate = \"\";\n    return Buffer.from(str, this.enc);\n  }\n};","map":{"version":3,"names":["Buffer","require","module","exports","utf8","type","bomAware","cesu8","unicode11utf8","ucs2","utf16le","binary","base64","hex","_internal","InternalCodec","codecOptions","iconv","enc","encodingName","encoder","InternalEncoderBase64","InternalEncoderUtf8","InternalEncoderCesu8","from","toString","decoder","InternalDecoderCesu8","defaultCharUnicode","prototype","InternalEncoder","InternalDecoder","StringDecoder","options","codec","write","buf","isBuffer","end","str","prevStr","completeQuads","length","slice","alloc","bufIdx","i","charCode","charCodeAt","acc","contBytes","accBytes","res","curByte","String","fromCharCode","highSurrogate"],"sources":["C:/Users/Flame/sadseditor/sadseditor/client/node_modules/raw-body/node_modules/iconv-lite/encodings/internal.js"],"sourcesContent":["\"use strict\"\nvar Buffer = require(\"safer-buffer\").Buffer\n\n// Export Node.js internal encodings.\n\nmodule.exports = {\n  // Encodings\n  utf8: { type: \"_internal\", bomAware: true },\n  cesu8: { type: \"_internal\", bomAware: true },\n  unicode11utf8: \"utf8\",\n\n  ucs2: { type: \"_internal\", bomAware: true },\n  utf16le: \"ucs2\",\n\n  binary: { type: \"_internal\" },\n  base64: { type: \"_internal\" },\n  hex: { type: \"_internal\" },\n\n  // Codec.\n  _internal: InternalCodec\n}\n\n// ------------------------------------------------------------------------------\n\nfunction InternalCodec (codecOptions, iconv) {\n  this.enc = codecOptions.encodingName\n  this.bomAware = codecOptions.bomAware\n\n  if (this.enc === \"base64\") { this.encoder = InternalEncoderBase64 } else if (this.enc === \"utf8\") { this.encoder = InternalEncoderUtf8 } else if (this.enc === \"cesu8\") {\n    this.enc = \"utf8\" // Use utf8 for decoding.\n    this.encoder = InternalEncoderCesu8\n\n    // Add decoder for versions of Node not supporting CESU-8\n    if (Buffer.from(\"eda0bdedb2a9\", \"hex\").toString() !== \"ðŸ’©\") {\n      this.decoder = InternalDecoderCesu8\n      this.defaultCharUnicode = iconv.defaultCharUnicode\n    }\n  }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder\nInternalCodec.prototype.decoder = InternalDecoder\n\n// ------------------------------------------------------------------------------\n\n// We use node.js internal decoder. Its signature is the same as ours.\nvar StringDecoder = require(\"string_decoder\").StringDecoder\n\nfunction InternalDecoder (options, codec) {\n  this.decoder = new StringDecoder(codec.enc)\n}\n\nInternalDecoder.prototype.write = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf)\n  }\n\n  return this.decoder.write(buf)\n}\n\nInternalDecoder.prototype.end = function () {\n  return this.decoder.end()\n}\n\n// ------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder (options, codec) {\n  this.enc = codec.enc\n}\n\nInternalEncoder.prototype.write = function (str) {\n  return Buffer.from(str, this.enc)\n}\n\nInternalEncoder.prototype.end = function () {\n}\n\n// ------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\nfunction InternalEncoderBase64 (options, codec) {\n  this.prevStr = \"\"\n}\n\nInternalEncoderBase64.prototype.write = function (str) {\n  str = this.prevStr + str\n  var completeQuads = str.length - (str.length % 4)\n  this.prevStr = str.slice(completeQuads)\n  str = str.slice(0, completeQuads)\n\n  return Buffer.from(str, \"base64\")\n}\n\nInternalEncoderBase64.prototype.end = function () {\n  return Buffer.from(this.prevStr, \"base64\")\n}\n\n// ------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\nfunction InternalEncoderCesu8 (options, codec) {\n}\n\nInternalEncoderCesu8.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length * 3); var bufIdx = 0\n  for (var i = 0; i < str.length; i++) {\n    var charCode = str.charCodeAt(i)\n    // Naive implementation, but it works because CESU-8 is especially easy\n    // to convert from UTF-16 (which all JS strings are encoded in).\n    if (charCode < 0x80) { buf[bufIdx++] = charCode } else if (charCode < 0x800) {\n      buf[bufIdx++] = 0xC0 + (charCode >>> 6)\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f)\n    } else { // charCode will always be < 0x10000 in javascript.\n      buf[bufIdx++] = 0xE0 + (charCode >>> 12)\n      buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f)\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f)\n    }\n  }\n  return buf.slice(0, bufIdx)\n}\n\nInternalEncoderCesu8.prototype.end = function () {\n}\n\n// ------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\nfunction InternalDecoderCesu8 (options, codec) {\n  this.acc = 0\n  this.contBytes = 0\n  this.accBytes = 0\n  this.defaultCharUnicode = codec.defaultCharUnicode\n}\n\nInternalDecoderCesu8.prototype.write = function (buf) {\n  var acc = this.acc; var contBytes = this.contBytes; var accBytes = this.accBytes\n  var res = \"\"\n  for (var i = 0; i < buf.length; i++) {\n    var curByte = buf[i]\n    if ((curByte & 0xC0) !== 0x80) { // Leading byte\n      if (contBytes > 0) { // Previous code is invalid\n        res += this.defaultCharUnicode\n        contBytes = 0\n      }\n\n      if (curByte < 0x80) { // Single-byte code\n        res += String.fromCharCode(curByte)\n      } else if (curByte < 0xE0) { // Two-byte code\n        acc = curByte & 0x1F\n        contBytes = 1; accBytes = 1\n      } else if (curByte < 0xF0) { // Three-byte code\n        acc = curByte & 0x0F\n        contBytes = 2; accBytes = 1\n      } else { // Four or more are not supported for CESU-8.\n        res += this.defaultCharUnicode\n      }\n    } else { // Continuation byte\n      if (contBytes > 0) { // We're waiting for it.\n        acc = (acc << 6) | (curByte & 0x3f)\n        contBytes--; accBytes++\n        if (contBytes === 0) {\n          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n          if (accBytes === 2 && acc < 0x80 && acc > 0) {\n            res += this.defaultCharUnicode\n          } else if (accBytes === 3 && acc < 0x800) {\n            res += this.defaultCharUnicode\n          } else {\n            // Actually add character.\n            res += String.fromCharCode(acc)\n          }\n        }\n      } else { // Unexpected continuation byte\n        res += this.defaultCharUnicode\n      }\n    }\n  }\n  this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes\n  return res\n}\n\nInternalDecoderCesu8.prototype.end = function () {\n  var res = 0\n  if (this.contBytes > 0) { res += this.defaultCharUnicode }\n  return res\n}\n\n// ------------------------------------------------------------------------------\n// check the chunk boundaries for surrogate pair\n\nfunction InternalEncoderUtf8 (options, codec) {\n  this.highSurrogate = \"\"\n}\n\nInternalEncoderUtf8.prototype.write = function (str) {\n  if (this.highSurrogate) {\n    str = this.highSurrogate + str\n    this.highSurrogate = \"\"\n  }\n\n  if (str.length > 0) {\n    var charCode = str.charCodeAt(str.length - 1)\n    if (charCode >= 0xd800 && charCode < 0xdc00) {\n      this.highSurrogate = str[str.length - 1]\n      str = str.slice(0, str.length - 1)\n    }\n  }\n\n  return Buffer.from(str, this.enc)\n}\n\nInternalEncoderUtf8.prototype.end = function () {\n  if (this.highSurrogate) {\n    var str = this.highSurrogate\n    this.highSurrogate = \"\"\n    return Buffer.from(str, this.enc)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}